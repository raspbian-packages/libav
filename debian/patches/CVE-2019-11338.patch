From 54655623a82632e7624714d7b2a3e039dc5faa7e Mon Sep 17 00:00:00 2001
From: Michael Niedermayer <michael@niedermayer.cc>
Date: Sat, 23 Mar 2019 20:55:08 +0100
Subject: [PATCH] avcodec/hevc: Avoid only partly skiping duplicate first
 slices

Fixes: NULL pointer dereference and out of array access
Fixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432
Fixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304

This also fixes the return code for explode mode

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: James Almer <jamrial@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
---
 libavcodec/hevc.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

[sunweaver] Rebase for patching libav in Debian jessie LTS.

    This patch implicitly ships the previous change:

    commit 70c8c8a818f39bc262565ec29fae2baffb3e1660
    Author: James Almer <jamrial@gmail.com>
    Date:   Mon Mar 18 17:25:58 2019 -0300

        avcodec/hevcdec: decode at most one slice reporting being the first in the picture
    
        Fixes deadlocks when decoding packets containing more than one of the aforementioned
        slices when using frame threads.
    
        Tested-by: Derek Buitenhuis <derek.buitenhuis@gmail.com>
        Signed-off-by: James Almer <jamrial@gmail.com>

--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -461,6 +461,11 @@
 
     // Coded parameters
     sh->first_slice_in_pic_flag = get_bits1(gb);
+    if (s->ref && sh->first_slice_in_pic_flag) {
+        av_log(s->avctx, AV_LOG_ERROR, "Two slices reporting being the first in the same frame.\n");
+        return 1; // This slice will be skiped later, do not corrupt state
+    }
+
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
@@ -2900,6 +2905,8 @@
         ret = ff_hevc_output_frame(s, data, 1);
         if (ret < 0)
             return ret;
+        if (ret == 1)
+            return AVERROR_INVALIDDATA;
 
         *got_output = ret;
         return 0;
